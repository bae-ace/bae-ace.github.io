{
    "version": "https://jsonfeed.org/version/1",
    "title": "bae的博客 • All posts by \"二进制安全\" category",
    "description": "bae的个人博客",
    "home_page_url": "https://bae-ace.github.io",
    "items": [
        {
            "id": "https://bae-ace.github.io/2025/07/22/ELF-%E6%96%87%E4%BB%B6%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6%E4%B8%8E-ROP-%E6%9E%84%E9%80%A0%E8%AF%A6%E8%A7%A3/",
            "url": "https://bae-ace.github.io/2025/07/22/ELF-%E6%96%87%E4%BB%B6%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6%E4%B8%8E-ROP-%E6%9E%84%E9%80%A0%E8%AF%A6%E8%A7%A3/",
            "title": "ELF 文件保护机制与 ROP 构造详解",
            "date_published": "2025-07-22T12:41:04.000Z",
            "content_html": "<h1 id=\"ELF-文件保护机制与-ROP-构造详解\"><a href=\"#ELF-文件保护机制与-ROP-构造详解\" class=\"headerlink\" title=\"ELF 文件保护机制与 ROP 构造详解\"></a>ELF 文件保护机制与 ROP 构造详解</h1><p>在 CTF（Capture The Flag）竞赛和二进制漏洞利用中，理解 ELF（Executable and Linkable Format）文件的架构信息及其保护机制至关重要。本文将详细分析 ELF 文件的架构特性、常见保护机制、函数调用约定，以及如何通过 ROP（Return-Oriented Programming）技术进行漏洞利用。</p>\n<h2 id=\"ELF-架构信息\"><a href=\"#ELF-架构信息\" class=\"headerlink\" title=\"ELF 架构信息\"></a>ELF 架构信息</h2><p>ELF 文件是 Linux 系统下常见的可执行文件格式，其架构信息直接影响漏洞利用的策略。以下是关键点：</p>\n<ul>\n<li><strong>目标程序架构</strong>：本文以 <code>amd64-64-little</code>（64 位小端序）为例。</li>\n<li><strong>作用</strong>：<ul>\n<li><strong>函数调用约定</strong>：决定了参数传递方式（如寄存器或栈）。</li>\n<li><strong>ROP 构造</strong>：需要根据架构选择合适的 gadget。</li>\n<li><strong>系统调用号</strong>：不同架构下系统调用号（如 <code>read</code>、<code>write</code>）存在差异。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"保护机制总览\"><a href=\"#保护机制总览\" class=\"headerlink\" title=\"保护机制总览\"></a>保护机制总览</h2><p>ELF 文件通常启用多种保护机制以增强安全性。以下是常见保护机制及其在 PWN（二进制漏洞利用）中的作用与绕过方式：</p>\n<table>\n<thead>\n<tr>\n<th>保护项</th>\n<th>状态</th>\n<th>说明</th>\n<th>在 PWN 中的作用与利用方式</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>RELRO</strong></td>\n<td>Partial RELRO</td>\n<td>GOT 表部分受保护，GOT 可写</td>\n<td>可通过 ret2got 改写函数指针（如 <code>write</code> → <code>system</code>）</td>\n</tr>\n<tr>\n<td><strong>RELRO</strong></td>\n<td>Full RELRO</td>\n<td>GOT 表完全不可写</td>\n<td>无法改写 GOT，只能泄露 GOT 地址后构造 ROP</td>\n</tr>\n<tr>\n<td><strong>Stack Canary</strong></td>\n<td>No Canary Found</td>\n<td>栈无溢出检测</td>\n<td>可直接栈溢出控制返回地址</td>\n</tr>\n<tr>\n<td><strong>Stack Canary</strong></td>\n<td>Canary Found</td>\n<td>启用栈溢出检测机制</td>\n<td>需先泄露 Canary 值，否则程序崩溃</td>\n</tr>\n<tr>\n<td><strong>NX</strong></td>\n<td>NX Enabled</td>\n<td>栈不可执行</td>\n<td>无法执行 Shellcode，需用 ROP 或 ret2libc</td>\n</tr>\n<tr>\n<td><strong>PIE</strong></td>\n<td>No PIE (固定基址，如 0x400000)</td>\n<td>程序基址固定</td>\n<td>地址可静态分析，ROP 构造更简单</td>\n</tr>\n<tr>\n<td><strong>PIE</strong></td>\n<td>PIE Enabled</td>\n<td>基址随机化</td>\n<td>需先泄露模块基址，ROP 构造更复杂</td>\n</tr>\n</tbody></table>\n<h3 id=\"CTF-常见题型与保护机制\"><a href=\"#CTF-常见题型与保护机制\" class=\"headerlink\" title=\"CTF 常见题型与保护机制\"></a>CTF 常见题型与保护机制</h3><p>不同类型的 CTF 题目通常搭配特定的保护机制，影响利用方式：</p>\n<ul>\n<li><strong>ROP &#x2F; ret2libc 题</strong>：通常有 NX 保护，无 PIE 或仅 Partial RELRO，便于构造 ROP 链。</li>\n<li><strong>格式化字符串题</strong>：常搭配 Full RELRO，限制 GOT 重写，需利用格式化字符串漏洞泄露地址。</li>\n<li><strong>堆题</strong>：通常有 Stack Canary，挑战在于绕过 Canary 或利用堆漏洞。</li>\n<li><strong>Shellcode 类题</strong>：一般无 NX 保护，允许在栈上直接执行注入的 Shellcode。</li>\n</ul>\n<h2 id=\"函数原型与调用方式\"><a href=\"#函数原型与调用方式\" class=\"headerlink\" title=\"函数原型与调用方式\"></a>函数原型与调用方式</h2><h3 id=\"常用函数原型\"><a href=\"#常用函数原型\" class=\"headerlink\" title=\"常用函数原型\"></a>常用函数原型</h3><p>以下是 PWN 中常用的标准库函数及其参数说明：</p>\n<ol>\n<li><p><strong><code>ssize_t write(int fd, const void *buf, size_t count);</code></strong></p>\n<ul>\n<li><code>fd</code>：文件描述符（如 <code>1</code> 表示标准输出）。</li>\n<li><code>buf</code>：待输出数据的起始地址，可用于泄露内存内容。</li>\n<li><code>count</code>：输出字节数，需控制以避免泄露过多数据。</li>\n</ul>\n</li>\n<li><p><strong><code>ssize_t read(int fd, void *buf, size_t count);</code></strong></p>\n<ul>\n<li><code>fd</code>：文件描述符（如 <code>0</code> 表示标准输入）。</li>\n<li><code>buf</code>：写入数据的目标地址（如栈、堆或 BSS 段）。</li>\n<li><code>count</code>：读取字节数，可用于触发溢出或布置 ROP 链。</li>\n</ul>\n</li>\n<li><p><strong><code>int puts(const char *s);</code></strong></p>\n<ul>\n<li><code>s</code>：字符串起始地址，遇 <code>\\x00</code> 终止。</li>\n<li>常用于泄露 GOT 表中的函数地址（如 <code>puts(puts_got)</code>）。</li>\n</ul>\n</li>\n<li><p><strong><code>int printf(const char *format, ...);</code></strong></p>\n<ul>\n<li><code>format</code>：格式化字符串。</li>\n<li>可利用格式化字符串漏洞泄露任意地址内容。</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"参数传递方式对比\"><a href=\"#参数传递方式对比\" class=\"headerlink\" title=\"参数传递方式对比\"></a>参数传递方式对比</h3><table>\n<thead>\n<tr>\n<th>架构</th>\n<th>参数传递方式</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>32 位 (x86)</strong></td>\n<td>所有参数通过栈从右向左压入</td>\n</tr>\n<tr>\n<td><strong>64 位 (x86_64)</strong></td>\n<td>前 6 个参数通过寄存器传递：<code>RDI</code>, <code>RSI</code>, <code>RDX</code>, <code>RCX</code>, <code>R8</code>, <code>R9</code></td>\n</tr>\n</tbody></table>\n<p><strong>提示</strong>：在 64 位 ROP 构造中，常用 gadget 包括：</p>\n<ul>\n<li><code>pop rdi; ret</code></li>\n<li><code>pop rsi; pop r15; ret</code></li>\n<li><code>pop rdx; ret</code></li>\n</ul>\n<h3 id=\"系统调用号（syscall）\"><a href=\"#系统调用号（syscall）\" class=\"headerlink\" title=\"系统调用号（syscall）\"></a>系统调用号（syscall）</h3><p>系统调用号因架构不同而异，常用函数的调用号如下：</p>\n<table>\n<thead>\n<tr>\n<th>函数</th>\n<th>x86 (32 位)</th>\n<th>x86_64 (64 位)</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>read</code></td>\n<td>3</td>\n<td>0</td>\n</tr>\n<tr>\n<td><code>write</code></td>\n<td>4</td>\n<td>1</td>\n</tr>\n<tr>\n<td><code>execve</code></td>\n<td>11</td>\n<td>59</td>\n</tr>\n</tbody></table>\n<ul>\n<li><strong>x86</strong>：使用 <code>int 0x80</code> 触发系统调用。</li>\n<li><strong>x86_64</strong>：使用 <code>syscall</code> 指令，通过设置 <code>rax</code> 寄存器控制系统调用类型。</li>\n</ul>\n<h2 id=\"常见函数-ROP-构造\"><a href=\"#常见函数-ROP-构造\" class=\"headerlink\" title=\"常见函数 ROP 构造\"></a>常见函数 ROP 构造</h2><p>以下展示如何针对常用函数构造 ROP 链，分别以 32 位和 64 位架构为例。假设使用 <code>pwntools</code> 的 <code>flat</code> 函数来构造 payload。</p>\n<h3 id=\"write-函数\"><a href=\"#write-函数\" class=\"headerlink\" title=\"write 函数\"></a>write 函数</h3><ul>\n<li><strong>32 位构造</strong>：</li>\n</ul>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\">payload = flat(<br>    <span class=\"hljs-string\">b&#x27;A&#x27;</span> * offset,  <span class=\"hljs-comment\"># 填充至返回地址</span><br>    write_plt,      <span class=\"hljs-comment\"># write 函数 PLT 地址</span><br>    main_addr,      <span class=\"hljs-comment\"># 返回地址（通常回到 main）</span><br>    <span class=\"hljs-number\">1</span>,              <span class=\"hljs-comment\"># fd = stdout</span><br>    write_got,      <span class=\"hljs-comment\"># buf = GOT 地址，用于泄露</span><br>    <span class=\"hljs-number\">4</span>               <span class=\"hljs-comment\"># count = 4 字节</span><br>)<br></code></pre></td></tr></table></figure>\n\n<ul>\n<li><strong>64 位构造</strong>：</li>\n</ul>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\">payload = flat(<br>    pop_rdi, <span class=\"hljs-number\">1</span>,         <span class=\"hljs-comment\"># RDI = 1 (stdout)</span><br>    pop_rsi_r15, write_got, <span class=\"hljs-number\">0</span>,  <span class=\"hljs-comment\"># RSI = GOT 地址</span><br>    pop_rdx, <span class=\"hljs-number\">8</span>,         <span class=\"hljs-comment\"># RDX = 8 字节</span><br>    write_plt           <span class=\"hljs-comment\"># 调用 write</span><br>)<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"read-函数\"><a href=\"#read-函数\" class=\"headerlink\" title=\"read 函数\"></a>read 函数</h3><ul>\n<li><strong>32 位构造</strong>：</li>\n</ul>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\">payload = flat(<br>    <span class=\"hljs-string\">b&#x27;A&#x27;</span> * offset,  <span class=\"hljs-comment\"># 填充至返回地址</span><br>    read_plt,       <span class=\"hljs-comment\"># read 函数 PLT 地址</span><br>    ret_addr,       <span class=\"hljs-comment\"># 返回地址</span><br>    <span class=\"hljs-number\">0</span>,              <span class=\"hljs-comment\"># fd = stdin</span><br>    buf_addr,       <span class=\"hljs-comment\"># 目标地址（如 BSS 段）</span><br>    <span class=\"hljs-number\">100</span>             <span class=\"hljs-comment\"># count = 100 字节</span><br>)<br></code></pre></td></tr></table></figure>\n\n<ul>\n<li><strong>64 位构造</strong>：</li>\n</ul>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\">payload = flat(<br>    pop_rdi, <span class=\"hljs-number\">0</span>,         <span class=\"hljs-comment\"># RDI = 0 (stdin)</span><br>    pop_rsi_r15, buf_addr, <span class=\"hljs-number\">0</span>,  <span class=\"hljs-comment\"># RSI = 目标地址</span><br>    pop_rdx, <span class=\"hljs-number\">100</span>,       <span class=\"hljs-comment\"># RDX = 100 字节</span><br>    read_plt,           <span class=\"hljs-comment\"># 调用 read</span><br>    main_addr           <span class=\"hljs-comment\"># 返回 main</span><br>)<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"puts-函数\"><a href=\"#puts-函数\" class=\"headerlink\" title=\"puts 函数\"></a>puts 函数</h3><ul>\n<li><strong>32 位构造</strong>：</li>\n</ul>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\">payload = flat(<br>    <span class=\"hljs-string\">b&#x27;A&#x27;</span> * offset,  <span class=\"hljs-comment\"># 填充至返回地址</span><br>    puts_plt,       <span class=\"hljs-comment\"># puts 函数 PLT 地址</span><br>    main_addr,      <span class=\"hljs-comment\"># 返回地址</span><br>    puts_got        <span class=\"hljs-comment\"># 参数：puts GOT 地址</span><br>)<br></code></pre></td></tr></table></figure>\n\n<ul>\n<li><strong>64 位构造</strong>：</li>\n</ul>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\">payload = flat(<br>    pop_rdi, puts_got,  <span class=\"hljs-comment\"># RDI = puts GOT 地址</span><br>    puts_plt,           <span class=\"hljs-comment\"># 调用 puts</span><br>    main_addr           <span class=\"hljs-comment\"># 返回 main</span><br>)<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"printf-函数（格式化字符串泄露）\"><a href=\"#printf-函数（格式化字符串泄露）\" class=\"headerlink\" title=\"printf 函数（格式化字符串泄露）\"></a>printf 函数（格式化字符串泄露）</h3><ul>\n<li><strong>32 位构造</strong>：</li>\n</ul>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\">payload = flat(<br>    <span class=\"hljs-string\">b&#x27;A&#x27;</span> * offset,  <span class=\"hljs-comment\"># 填充至返回地址</span><br>    printf_plt,     <span class=\"hljs-comment\"># printf 函数 PLT 地址</span><br>    main_addr,      <span class=\"hljs-comment\"># 返回地址</span><br>    got_puts        <span class=\"hljs-comment\"># 参数：格式化字符串（如 &quot;%s&quot;）</span><br>)<br></code></pre></td></tr></table></figure>\n\n<ul>\n<li><strong>64 位构造</strong>：</li>\n</ul>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\">payload = flat(<br>    pop_rdi, format_str,    <span class=\"hljs-comment\"># RDI = 格式化字符串地址</span><br>    pop_rsi_r15, got_read, <span class=\"hljs-number\">0</span>,  <span class=\"hljs-comment\"># RSI = 目标地址</span><br>    printf_plt,             <span class=\"hljs-comment\"># 调用 printf</span><br>    main_addr               <span class=\"hljs-comment\"># 返回 main</span><br>)<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"ret2libc-利用流程\"><a href=\"#ret2libc-利用流程\" class=\"headerlink\" title=\"ret2libc 利用流程\"></a>ret2libc 利用流程</h2><p><code>ret2libc</code> 是一种经典的漏洞利用技术，绕过 NX 保护，通过调用 libc 中的函数（如 <code>system(&quot;/bin/sh&quot;)</code>）获取 shell。以下是常规流程：</p>\n<ol>\n<li><strong>泄露 GOT 表地址</strong>：利用 <code>puts</code> 或 <code>write</code> 泄露 <code>puts@got</code> 的真实地址。</li>\n<li><strong>计算 libc 基址</strong>：通过接收到的地址，结合 libc 的偏移量，计算 libc 基址。</li>\n<li><strong>获取关键函数地址</strong>：利用 libc 基址和偏移，得到 <code>system</code> 和 <code>&quot;/bin/sh&quot;</code> 字符串的地址。</li>\n<li><strong>构造 ROP 链</strong>：调用 <code>system(&quot;/bin/sh&quot;)</code> 执行 shell。</li>\n</ol>\n<h2 id=\"ROP-汇总对比表\"><a href=\"#ROP-汇总对比表\" class=\"headerlink\" title=\"ROP 汇总对比表\"></a>ROP 汇总对比表</h2><table>\n<thead>\n<tr>\n<th>函数</th>\n<th>架构</th>\n<th>参数方式</th>\n<th>构造说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>write</td>\n<td>32 位</td>\n<td>栈上传参</td>\n<td><code>fd=1, buf=got, count=4</code></td>\n</tr>\n<tr>\n<td>write</td>\n<td>64 位</td>\n<td>RDI, RSI, RDX</td>\n<td>ROP 控制 3 个寄存器后调用</td>\n</tr>\n<tr>\n<td>read</td>\n<td>32 位</td>\n<td>栈上传参</td>\n<td>用于栈迁移或注入后续 ROP 链</td>\n</tr>\n<tr>\n<td>read</td>\n<td>64 位</td>\n<td>RDI, RSI, RDX</td>\n<td>常与 <code>leave_ret</code> gadget 搭配使用</td>\n</tr>\n<tr>\n<td>puts</td>\n<td>32 位</td>\n<td>栈上传参</td>\n<td>调用 <code>puts(got_xxx)</code> 泄露地址</td>\n</tr>\n<tr>\n<td>puts</td>\n<td>64 位</td>\n<td>RDI -&gt; GOT 地址</td>\n<td><code>pop rdi; call puts</code></td>\n</tr>\n<tr>\n<td>printf</td>\n<td>32 位</td>\n<td>栈上传参</td>\n<td><code>printf(fmt, val)</code> 用于格式化泄露</td>\n</tr>\n<tr>\n<td>printf</td>\n<td>64 位</td>\n<td>RDI, RSI</td>\n<td>RDI 指向格式化字符串，RSI 指向地址</td>\n</tr>\n</tbody></table>\n<h2 id=\"实用工具提示\"><a href=\"#实用工具提示\" class=\"headerlink\" title=\"实用工具提示\"></a>实用工具提示</h2><ul>\n<li><strong>ROPgadget</strong>：用于查找二进制文件中的 gadget，例如：<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">ROPgadget --binary a.out --only <span class=\"hljs-string\">&#x27;pop|ret&#x27;</span><br></code></pre></td></tr></table></figure></li>\n<li><strong>pwndbg</strong>：GDB 插件，方便调试和查找 gadget。</li>\n<li><strong>pwntools</strong>：Python 库，简化 ROP 链构造和 payload 生成。</li>\n</ul>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>ELF 文件的保护机制和架构特性直接影响漏洞利用的难度和方式。理解 RELRO、Canary、NX 和 PIE 等保护机制的作用，以及如何通过 ROP 和 ret2libc 技术绕过这些保护，是 CTF 和二进制安全研究的核心技能。希望本文的分析和示例代码能为你的 PWN 学习提供帮助！</p>\n",
            "tags": [
                "PWN",
                "ELF",
                "ROP",
                "CTF",
                "二进制安全"
            ]
        }
    ]
}